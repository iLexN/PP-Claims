'use strict';var globalOptions=require('../options');var helpers=require('../helpers');function networkFirst(request,values,options){options=options||{};var successResponses=options.successResponses||globalOptions.successResponses;var networkTimeoutSeconds=options.networkTimeoutSeconds||globalOptions.networkTimeoutSeconds;helpers.debug('Strategy: network first ['+request.url+']',options);return helpers.openCache(options).then(function(cache){var timeoutId;var promises=[];var originalResponse;if(networkTimeoutSeconds){var cacheWhenTimedOutPromise=new Promise(function(resolve){timeoutId=setTimeout(function(){cache.match(request).then(function(response){if(response){resolve(response);}});},networkTimeoutSeconds*1000);});promises.push(cacheWhenTimedOutPromise);}
var networkPromise=helpers.fetchAndCache(request,options).then(function(response){if(timeoutId){clearTimeout(timeoutId);}
if(successResponses.test(response.status)){return response;}
helpers.debug('Response was an HTTP error: '+response.statusText,options);originalResponse=response;throw new Error('Bad response');}).catch(function(error){helpers.debug('Network or response error, fallback to cache ['+
request.url+']',options);return cache.match(request).then(function(response){if(response){return response;}
if(originalResponse){return originalResponse;}
throw error;});});promises.push(networkPromise);return Promise.race(promises);});}
module.exports=networkFirst;